/* Copyright (C) 2012 Christian A. Kothe

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

This software uses the following libraries:


pugixml (https://pugixml.org), MIT. pugixml is Copyright (C) 2006-2018 Arseny Kapoulkine.
Boost (https://boost.org), Boost Software License
Loguru (https://github.com/emilk/loguru), Public Domain
Catch2 (https://github.com/catchorg/Catch2), Boost Software License */
/* automatically generated by rust-bindgen 0.60.1 */

pub type __int16_t = ::std::os::raw::c_short;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
#[doc = " For up to 24-bit precision measurements in the appropriate physical unit (e.g., microvolts)."]
#[doc = " Integers from -16777216 to 16777216 are represented accurately."]
pub const lsl_channel_format_t_cft_float32: lsl_channel_format_t = 1;
#[doc = " For universal numeric data as long as permitted by network & disk budget."]
#[doc = " The largest representable integer is 53-bit."]
pub const lsl_channel_format_t_cft_double64: lsl_channel_format_t = 2;
#[doc = " For variable-length ASCII strings or data blobs, such as video frames, complex event"]
#[doc = "descriptions, etc."]
pub const lsl_channel_format_t_cft_string: lsl_channel_format_t = 3;
#[doc = " For high-rate digitized formats that require 32-bit precision."]
#[doc = " Depends critically on meta-data to represent meaningful units."]
#[doc = " Useful for application event codes or other coded data."]
pub const lsl_channel_format_t_cft_int32: lsl_channel_format_t = 4;
#[doc = " For very high rate signals (40Khz+) or consumer-grade audio."]
#[doc = " For professional audio float is recommended."]
pub const lsl_channel_format_t_cft_int16: lsl_channel_format_t = 5;
#[doc = " For binary signals or other coded data. Not recommended for encoding string data."]
pub const lsl_channel_format_t_cft_int8: lsl_channel_format_t = 6;
#[doc = " 64 bit integers. Support for this type is not yet exposed in all languages."]
#[doc = " Also, some builds of liblsl will not be able to send or receive data of this type."]
pub const lsl_channel_format_t_cft_int64: lsl_channel_format_t = 7;
#[doc = " Can not be transmitted."]
pub const lsl_channel_format_t_cft_undefined: lsl_channel_format_t = 0;
#[doc = " Can not be transmitted."]
pub const lsl_channel_format_t__cft_maxval: lsl_channel_format_t = 2130706432;
#[doc = " Data format of a channel (each transmitted sample holds an array of channels), 4 bytes wide"]
pub type lsl_channel_format_t = ::std::os::raw::c_uint;
#[doc = " No automatic post-processing; return the ground-truth time stamps for manual"]
#[doc = "post-processing. This is the default behavior of the inlet."]
pub const lsl_processing_options_t_proc_none: lsl_processing_options_t = 0;
#[doc = " Perform automatic clock synchronization; equivalent to manually adding the time_correction()"]
#[doc = "value to the received time stamps."]
pub const lsl_processing_options_t_proc_clocksync: lsl_processing_options_t = 1;
#[doc = " Remove jitter from time stamps."]
#[doc = ""]
#[doc = " This will apply a smoothing algorithm to the received time stamps; the smoothing needs to see"]
#[doc = " a minimum number of samples (30-120 seconds worst-case) until the remaining jitter is"]
#[doc = " consistently below 1ms."]
pub const lsl_processing_options_t_proc_dejitter: lsl_processing_options_t = 2;
#[doc = " Force the time-stamps to be monotonically ascending."]
#[doc = ""]
#[doc = " Only makes sense if timestamps are dejittered."]
pub const lsl_processing_options_t_proc_monotonize: lsl_processing_options_t = 4;
#[doc = " Post-processing is thread-safe (same inlet can be read from by multiple threads);"]
#[doc = " uses somewhat more CPU."]
pub const lsl_processing_options_t_proc_threadsafe: lsl_processing_options_t = 8;
#[doc = " The combination of all possible post-processing options."]
pub const lsl_processing_options_t_proc_ALL: lsl_processing_options_t = 15;
#[doc = " The combination of all possible post-processing options."]
pub const lsl_processing_options_t__proc_maxval: lsl_processing_options_t = 2130706432;
#[doc = " Post-processing options for stream inlets."]
pub type lsl_processing_options_t = ::std::os::raw::c_uint;
#[doc = " No error occurred"]
pub const lsl_error_code_t_lsl_no_error: lsl_error_code_t = 0;
#[doc = " The operation failed due to a timeout."]
pub const lsl_error_code_t_lsl_timeout_error: lsl_error_code_t = -1;
#[doc = " The stream has been lost."]
pub const lsl_error_code_t_lsl_lost_error: lsl_error_code_t = -2;
#[doc = " An argument was incorrectly specified (e.g., wrong format or wrong length)."]
pub const lsl_error_code_t_lsl_argument_error: lsl_error_code_t = -3;
#[doc = " Some other internal error has happened."]
pub const lsl_error_code_t_lsl_internal_error: lsl_error_code_t = -4;
#[doc = " Some other internal error has happened."]
pub const lsl_error_code_t__lsl_error_code_maxval: lsl_error_code_t = 2130706432;
#[doc = " Possible error codes."]
pub type lsl_error_code_t = ::std::os::raw::c_int;
#[doc = " Keep legacy behavior: max_buffered / max_buflen is in seconds; use asynch transfer."]
pub const lsl_transport_options_t_transp_default: lsl_transport_options_t = 0;
#[doc = " The supplied max_buf value is in samples."]
pub const lsl_transport_options_t_transp_bufsize_samples: lsl_transport_options_t = 1;
#[doc = " The supplied max_buf should be scaled by 0.001."]
pub const lsl_transport_options_t_transp_bufsize_thousandths: lsl_transport_options_t = 2;
#[doc = " The supplied max_buf should be scaled by 0.001."]
pub const lsl_transport_options_t__lsl_transport_options_maxval: lsl_transport_options_t =
    2130706432;
#[doc = " Flags for outlet_ex and inlet_ex"]
pub type lsl_transport_options_t = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Return an explanation for the last error"]
    pub fn lsl_last_error() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Protocol version."]
    #[doc = ""]
    #[doc = " The major version is `protocol_version() / 100;`"]
    #[doc = " The minor version is `protocol_version() % 100;`"]
    #[doc = ""]
    #[doc = " Clients with different minor versions are protocol-compatible while clients"]
    #[doc = " with different major versions will refuse to work together."]
    pub fn lsl_protocol_version() -> i32;
}
extern "C" {
    #[doc = " Version of the liblsl library."]
    #[doc = ""]
    #[doc = " The major version is `library_version() / 100;`"]
    #[doc = " The minor version is `library_version() % 100;`"]
    pub fn lsl_library_version() -> i32;
}
extern "C" {
    #[doc = " Get a string containing library information."]
    #[doc = ""]
    #[doc = " The format of the string shouldn't be used for anything important except giving a debugging"]
    #[doc = " person a good idea which exact library version is used."]
    pub fn lsl_library_info() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Obtain a local system time stamp in seconds."]
    #[doc = ""]
    #[doc = " The resolution is better than a millisecond."]
    #[doc = " This reading can be used to assign time stamps to samples as they are being acquired."]
    #[doc = " If the \"age\" of a sample is known at a particular time (e.g., from USB transmission"]
    #[doc = " delays), it can be used as an offset to lsl_local_clock() to obtain a better estimate of"]
    #[doc = " when a sample was actually captured. See lsl_push_sample() for a use case."]
    pub fn lsl_local_clock() -> f64;
}
extern "C" {
    #[doc = " Deallocate a string that has been transferred to the application."]
    #[doc = ""]
    #[doc = " Rarely used: the only use case is to deallocate the contents of"]
    #[doc = " string-valued samples received from LSL in an application where"]
    #[doc = " no free() method is available (e.g., in some scripting languages)."]
    pub fn lsl_destroy_string(s: *mut ::std::os::raw::c_char);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lsl_streaminfo_struct_ {
    _unused: [u8; 0],
}
#[doc = " @class lsl_streaminfo"]
#[doc = " Handle to a stream info object."]
#[doc = ""]
#[doc = " Stores the declaration of a data stream."]
#[doc = " Represents the following information:"]
#[doc = ""]
#[doc = "  - stream data format (number of channels, channel format)"]
#[doc = "  - core information (stream name, content type, sampling rate)"]
#[doc = "  - optional meta-data about the stream content (channel labels, measurement units, etc.)"]
#[doc = ""]
#[doc = " Whenever a program wants to provide a new stream on the lab network it will typically first"]
#[doc = " create an lsl_streaminfo to describe its properties and then construct an #lsl_outlet with it to"]
#[doc = " create the stream on the network. Other parties who discover/resolve the outlet on the network"]
#[doc = " can query the stream info; it is also written to disk when recording the stream (playing a"]
#[doc = " similar role as a file header)."]
pub type lsl_streaminfo = *mut lsl_streaminfo_struct_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lsl_outlet_struct_ {
    _unused: [u8; 0],
}
#[doc = " @class lsl_outlet"]
#[doc = " A stream outlet handle."]
#[doc = " Outlets are used to make streaming data (and the meta-data) available on the lab network."]
pub type lsl_outlet = *mut lsl_outlet_struct_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lsl_inlet_struct_ {
    _unused: [u8; 0],
}
#[doc = " @class lsl_inlet"]
#[doc = " A stream inlet handle."]
#[doc = " Inlets are used to receive streaming data (and meta-data) from the lab network."]
pub type lsl_inlet = *mut lsl_inlet_struct_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lsl_xml_ptr_struct_ {
    _unused: [u8; 0],
}
#[doc = " @class lsl_xml_ptr"]
#[doc = " A lightweight XML element tree handle; models the description of a streaminfo object."]
#[doc = " XML elements behave like advanced pointers into memory that is owned by some respective"]
#[doc = " streaminfo."]
#[doc = " Has a name and can have multiple named children or have text content as value;"]
#[doc = " attributes are omitted."]
#[doc = " @note The interface is modeled after a subset of pugixml's node type and is compatible with it."]
#[doc = " Type-casts between pugi::xml_node_struct* and #lsl_xml_ptr are permitted (in both directions)"]
#[doc = " since the types are binary compatible."]
#[doc = " @sa [pugixml documentation](https://pugixml.org/docs/manual.html#access)."]
pub type lsl_xml_ptr = *mut lsl_xml_ptr_struct_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lsl_continuous_resolver_ {
    _unused: [u8; 0],
}
#[doc = " @class lsl_continuous_resolver"]
#[doc = ""]
#[doc = " Handle to a convenience object that resolves streams continuously in the background throughout"]
#[doc = " its lifetime and which can be queried at any time for the set of streams that are currently"]
#[doc = " visible on the network."]
pub type lsl_continuous_resolver = *mut lsl_continuous_resolver_;
extern "C" {
    #[doc = " Construct a new stream inlet from a resolved stream info."]
    #[doc = " @param info A resolved stream info object (as coming from one of the resolver functions)."]
    #[doc = " @note The inlet makes a copy of the info object at its construction."]
    #[doc = " @note The stream_inlet may also be constructed with a fully-specified stream_info, if the desired"]
    #[doc = " channel format and count is already known up-front, but this is  strongly discouraged and should"]
    #[doc = " only ever be done if there is no time to resolve the  stream up-front (e.g., due to limitations"]
    #[doc = " in the client program)."]
    #[doc = " @param max_buflen Optionally the maximum amount of data to buffer (in seconds if there is a"]
    #[doc = " nominal sampling rate, otherwise x100 in samples)."]
    #[doc = ""]
    #[doc = " Recording applications want to use a fairly large buffer size here, while real-time applications"]
    #[doc = " would only buffer as much as they need to perform their next calculation."]
    #[doc = ""]
    #[doc = " A good default is 360, which corresponds to 6 minutes of data."]
    #[doc = " @param max_chunklen Optionally the maximum size, in samples, at which chunks are transmitted."]
    #[doc = " If specified as 0, the chunk sizes preferred by the sender are used."]
    #[doc = " Recording applications can use a generous size here (leaving it to the network how  to pack"]
    #[doc = " things), while real-time applications may want a finer (perhaps 1-sample) granularity."]
    #[doc = " @param recover Try to silently recover lost streams that are recoverable (=those that that have a"]
    #[doc = " source_id set)."]
    #[doc = ""]
    #[doc = " It is generally a good idea to enable this, unless the application wants to act in a special way"]
    #[doc = " when a data provider has temporarily crashed."]
    #[doc = ""]
    #[doc = " If recover is 0 or the stream is not recoverable, most outlet functions will return an"]
    #[doc = " #lsl_lost_error if the stream's source is lost."]
    #[doc = " @return A newly created lsl_inlet handle or NULL in the event that an error occurred."]
    pub fn lsl_create_inlet(
        info: lsl_streaminfo,
        max_buflen: i32,
        max_chunklen: i32,
        recover: i32,
    ) -> lsl_inlet;
}
extern "C" {
    #[doc = " @copydoc lsl_create_inlet()"]
    #[doc = " @param flags An integer that is the result of bitwise OR'ing one or more options from"]
    #[doc = " #lsl_transport_options_t together (e.g., #transp_bufsize_samples)"]
    pub fn lsl_create_inlet_ex(
        info: lsl_streaminfo,
        max_buflen: i32,
        max_chunklen: i32,
        recover: i32,
        flags: lsl_transport_options_t,
    ) -> lsl_inlet;
}
extern "C" {
    #[doc = " Destructor."]
    #[doc = " The inlet will automatically disconnect if destroyed."]
    pub fn lsl_destroy_inlet(in_: lsl_inlet);
}
extern "C" {
    #[doc = " Retrieve the complete information of the given stream, including the extended description."]
    #[doc = " Can be invoked at any time of the stream's lifetime."]
    #[doc = " @param in The lsl_inlet object to act on."]
    #[doc = " @param timeout Timeout of the operation. Use LSL_FOREVER to effectively disable it."]
    #[doc = " @param[out] ec Error code: if nonzero, can be either lsl_timeout_error (if the timeout has"]
    #[doc = " expired) or #lsl_lost_error (if the stream source has been lost)."]
    #[doc = " @return A copy of the full streaminfo of the inlet or NULL in the event that an error happened."]
    #[doc = " @note It is the user's responsibility to destroy it when it is no longer needed."]
    pub fn lsl_get_fullinfo(in_: lsl_inlet, timeout: f64, ec: *mut i32) -> lsl_streaminfo;
}
extern "C" {
    #[doc = " Subscribe to the data stream."]
    #[doc = ""]
    #[doc = " All samples pushed in at the other end from this moment onwards will be queued and"]
    #[doc = " eventually be delivered in response to pull_sample() calls."]
    #[doc = " Pulling a sample without some preceding lsl_open_stream() is permitted (the stream will then be"]
    #[doc = " opened implicitly)."]
    #[doc = " @param in The lsl_inlet object to act on."]
    #[doc = " @param timeout Optional timeout of the operation. Use LSL_FOREVER to effectively disable it."]
    #[doc = " @param[out] ec Error code: if nonzero, can be either #lsl_timeout_error (if the timeout has"]
    #[doc = " expired) or lsl_lost_error (if the stream source has been lost)."]
    pub fn lsl_open_stream(in_: lsl_inlet, timeout: f64, ec: *mut i32);
}
extern "C" {
    #[doc = " Drop the current data stream."]
    #[doc = ""]
    #[doc = " All samples that are still buffered or in flight will be dropped and transmission"]
    #[doc = " and buffering of data for this inlet will be stopped. If an application stops being"]
    #[doc = " interested in data from a source (temporarily or not) but keeps the outlet alive,"]
    #[doc = " it should call lsl_close_stream() to not waste unnecessary system and network"]
    #[doc = " resources."]
    pub fn lsl_close_stream(in_: lsl_inlet);
}
extern "C" {
    #[doc = " @brief Retrieve an estimated time correction offset for the given stream."]
    #[doc = ""]
    #[doc = " The first call to this function takes several milliseconds until a reliable first estimate is"]
    #[doc = " obtained. Subsequent calls are instantaneous (and rely on periodic background updates)."]
    #[doc = ""]
    #[doc = " On a well-behaved network, the precision of these estimates should be below 1 ms (empirically it"]
    #[doc = " is within +/-0.2 ms)."]
    #[doc = ""]
    #[doc = " To get a measure of whether the network is well-behaved, use #lsl_time_correction_ex and check"]
    #[doc = " uncertainty (which maps to round-trip-time). 0.2 ms is typical of wired networks."]
    #[doc = ""]
    #[doc = " 2 ms is typical of wireless networks. The number can be much higher on poor networks."]
    #[doc = ""]
    #[doc = " @param in The lsl_inlet object to act on."]
    #[doc = " @param timeout Timeout to acquire the first time-correction estimate."]
    #[doc = " Use LSL_FOREVER to defuse the timeout."]
    #[doc = " @param[out] ec Error code: if nonzero, can be either #lsl_timeout_error (if the timeout has"]
    #[doc = " expired) or lsl_lost_error (if the stream source has been lost)."]
    #[doc = " @return The time correction estimate."]
    #[doc = " This is the number that needs to be added to a time stamp that was remotely generated via"]
    #[doc = " lsl_local_clock() to map it into the local clock domain of this machine."]
    pub fn lsl_time_correction(in_: lsl_inlet, timeout: f64, ec: *mut i32) -> f64;
}
extern "C" {
    #[doc = " @copydoc lsl_time_correction()"]
    #[doc = " @param remote_time The current time of the remote computer that was used to generate this"]
    #[doc = " time_correction."]
    #[doc = " If desired, the client can fit time_correction vs remote_time to improve the real-time"]
    #[doc = " time_correction further."]
    #[doc = " @param uncertainty The maximum uncertainty of the given time correction."]
    pub fn lsl_time_correction_ex(
        in_: lsl_inlet,
        remote_time: *mut f64,
        uncertainty: *mut f64,
        timeout: f64,
        ec: *mut i32,
    ) -> f64;
}
extern "C" {
    #[doc = " Set post-processing flags to use."]
    #[doc = ""]
    #[doc = " By default, the inlet performs NO post-processing and returns the ground-truth time stamps, which"]
    #[doc = " can then be manually synchronized using time_correction(), and then smoothed/dejittered if"]
    #[doc = " desired."]
    #[doc = ""]
    #[doc = " This function allows automating these two and possibly more operations."]
    #[doc = " @warning When you enable this, you will no longer receive or be able to recover the original time"]
    #[doc = " stamps."]
    #[doc = " @param in The lsl_inlet object to act on."]
    #[doc = " @param flags An integer that is the result of bitwise OR'ing one or more options from"]
    #[doc = " #lsl_processing_options_t together (e.g., #proc_clocksync|#proc_dejitter);"]
    #[doc = " a good setting is to use #proc_ALL."]
    #[doc = " @return The error code: if nonzero, can be #lsl_argument_error if an unknown flag was passed in."]
    pub fn lsl_set_postprocessing(in_: lsl_inlet, flags: u32) -> i32;
}
extern "C" {
    #[doc = " Pull a sample from the inlet and read it into a pointer to values."]
    #[doc = " Handles type checking & conversion."]
    #[doc = " @param in The #lsl_inlet object to act on."]
    #[doc = " @param[out] buffer A pointer to hold the resulting values."]
    #[doc = " @param buffer_elements The number of samples allocated in the buffer."]
    #[doc = " @attention It is the responsibility of the user to allocate enough memory."]
    #[doc = " @param timeout The timeout for this operation, if any."]
    #[doc = " Use #LSL_FOREVER to effectively disable it. It is also permitted to use 0.0 here;"]
    #[doc = " in this case a sample is only returned if one is currently buffered."]
    #[doc = " @param[out] ec Error code: can be either no error or #lsl_lost_error"]
    #[doc = " (if the stream source has been lost).<br>"]
    #[doc = " @note If the timeout expires before a new sample was received the function returns 0.0;"]
    #[doc = " ec is *not* set to #lsl_timeout_error (because this case is not considered an error condition)."]
    #[doc = " @return The capture time of the sample on the remote machine, or 0.0 if no new sample was"]
    #[doc = " available. To remap this time stamp to the local clock, add the value returned by"]
    #[doc = " lsl_time_correction() to it."]
    #[doc = " @{"]
    pub fn lsl_pull_sample_f(
        in_: lsl_inlet,
        buffer: *mut f32,
        buffer_elements: i32,
        timeout: f64,
        ec: *mut i32,
    ) -> f64;
}
extern "C" {
    pub fn lsl_pull_sample_d(
        in_: lsl_inlet,
        buffer: *mut f64,
        buffer_elements: i32,
        timeout: f64,
        ec: *mut i32,
    ) -> f64;
}
extern "C" {
    pub fn lsl_pull_sample_l(
        in_: lsl_inlet,
        buffer: *mut i64,
        buffer_elements: i32,
        timeout: f64,
        ec: *mut i32,
    ) -> f64;
}
extern "C" {
    pub fn lsl_pull_sample_i(
        in_: lsl_inlet,
        buffer: *mut i32,
        buffer_elements: i32,
        timeout: f64,
        ec: *mut i32,
    ) -> f64;
}
extern "C" {
    pub fn lsl_pull_sample_s(
        in_: lsl_inlet,
        buffer: *mut i16,
        buffer_elements: i32,
        timeout: f64,
        ec: *mut i32,
    ) -> f64;
}
extern "C" {
    pub fn lsl_pull_sample_c(
        in_: lsl_inlet,
        buffer: *mut ::std::os::raw::c_char,
        buffer_elements: i32,
        timeout: f64,
        ec: *mut i32,
    ) -> f64;
}
extern "C" {
    pub fn lsl_pull_sample_str(
        in_: lsl_inlet,
        buffer: *mut *mut ::std::os::raw::c_char,
        buffer_elements: i32,
        timeout: f64,
        ec: *mut i32,
    ) -> f64;
}
extern "C" {
    #[doc = " @copydoc lsl_pull_sample_f"]
    #[doc = " These strings may contains 0's, therefore the lengths are read into the buffer_lengths array."]
    #[doc = " @param buffer_lengths"]
    #[doc = " A pointer to an array that holds the resulting lengths for each returned binary string."]
    pub fn lsl_pull_sample_buf(
        in_: lsl_inlet,
        buffer: *mut *mut ::std::os::raw::c_char,
        buffer_lengths: *mut u32,
        buffer_elements: i32,
        timeout: f64,
        ec: *mut i32,
    ) -> f64;
}
extern "C" {
    #[doc = " Pull a sample from the inlet and read it into a custom struct or buffer."]
    #[doc = ""]
    #[doc = " Overall size checking but no type checking or conversion are done."]
    #[doc = " Do not use for variable-size/string-formatted streams."]
    #[doc = " @param in The #lsl_inlet object to act on."]
    #[doc = " @param[out] buffer A pointer to hold the resulting values."]
    #[doc = " @param buffer_bytes Length of the array held by buffer in bytes, not items"]
    #[doc = " @param timeout The timeout for this operation, if any."]
    #[doc = " Use #LSL_FOREVER to effectively disable it. It is also permitted to use 0.0 here;"]
    #[doc = " in this case a sample is only returned if one is currently buffered."]
    #[doc = " @param[out] ec Error code: can be either no error or #lsl_lost_error"]
    #[doc = " (if the stream source has been lost).<br>"]
    #[doc = " @note If the timeout expires before a new sample was received the function returns 0.0;"]
    #[doc = " ec is *not* set to #lsl_timeout_error (because this case is not considered an error condition)."]
    #[doc = " @return The capture time of the sample on the remote machine, or 0.0 if no new sample was"]
    #[doc = " available. To remap this time stamp to the local clock, add the value returned by"]
    #[doc = " lsl_time_correction() to it."]
    pub fn lsl_pull_sample_v(
        in_: lsl_inlet,
        buffer: *mut ::std::os::raw::c_void,
        buffer_bytes: i32,
        timeout: f64,
        ec: *mut i32,
    ) -> f64;
}
extern "C" {
    #[doc = " Pull a chunk of data from the inlet and read it into a buffer."]
    #[doc = ""]
    #[doc = " Handles type checking & conversion."]
    #[doc = ""]
    #[doc = " @attention Note that the provided data buffer size is measured in channel values (e.g. floats)"]
    #[doc = " rather than in samples."]
    #[doc = " @param in The lsl_inlet object to act on."]
    #[doc = " @param[out] data_buffer A pointer to a buffer of data values where the results shall be stored."]
    #[doc = " @param[out] timestamp_buffer A pointer to a double buffer where time stamps shall be stored."]
    #[doc = ""]
    #[doc = " If this is NULL, no time stamps will be returned."]
    #[doc = " @param data_buffer_elements The size of the data buffer, in channel data elements (of type T)."]
    #[doc = " Must be a multiple of the stream's channel count."]
    #[doc = " @param timestamp_buffer_elements The size of the timestamp buffer."]
    #[doc = ""]
    #[doc = " If a timestamp buffer is provided then this must correspond to the same number of samples as"]
    #[doc = " data_buffer_elements."]
    #[doc = " @param timeout The timeout for this operation, if any."]
    #[doc = ""]
    #[doc = " When the timeout expires, the function may return before the entire buffer is filled."]
    #[doc = " The default value of 0.0 will retrieve only data available for immediate pickup."]
    #[doc = " @param[out] ec Error code: can be either no error or #lsl_lost_error (if the stream source has"]
    #[doc = " been lost)."]
    #[doc = " @note if the timeout expires before a new sample was received the function returns 0.0;"]
    #[doc = " ec is *not* set to #lsl_timeout_error (because this case is not considered an error condition)."]
    #[doc = " @return data_elements_written Number of channel data elements written to the data buffer."]
    #[doc = " @{"]
    pub fn lsl_pull_chunk_f(
        in_: lsl_inlet,
        data_buffer: *mut f32,
        timestamp_buffer: *mut f64,
        data_buffer_elements: ::std::os::raw::c_ulong,
        timestamp_buffer_elements: ::std::os::raw::c_ulong,
        timeout: f64,
        ec: *mut i32,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn lsl_pull_chunk_d(
        in_: lsl_inlet,
        data_buffer: *mut f64,
        timestamp_buffer: *mut f64,
        data_buffer_elements: ::std::os::raw::c_ulong,
        timestamp_buffer_elements: ::std::os::raw::c_ulong,
        timeout: f64,
        ec: *mut i32,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn lsl_pull_chunk_l(
        in_: lsl_inlet,
        data_buffer: *mut i64,
        timestamp_buffer: *mut f64,
        data_buffer_elements: ::std::os::raw::c_ulong,
        timestamp_buffer_elements: ::std::os::raw::c_ulong,
        timeout: f64,
        ec: *mut i32,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn lsl_pull_chunk_i(
        in_: lsl_inlet,
        data_buffer: *mut i32,
        timestamp_buffer: *mut f64,
        data_buffer_elements: ::std::os::raw::c_ulong,
        timestamp_buffer_elements: ::std::os::raw::c_ulong,
        timeout: f64,
        ec: *mut i32,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn lsl_pull_chunk_s(
        in_: lsl_inlet,
        data_buffer: *mut i16,
        timestamp_buffer: *mut f64,
        data_buffer_elements: ::std::os::raw::c_ulong,
        timestamp_buffer_elements: ::std::os::raw::c_ulong,
        timeout: f64,
        ec: *mut i32,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn lsl_pull_chunk_c(
        in_: lsl_inlet,
        data_buffer: *mut ::std::os::raw::c_char,
        timestamp_buffer: *mut f64,
        data_buffer_elements: ::std::os::raw::c_ulong,
        timestamp_buffer_elements: ::std::os::raw::c_ulong,
        timeout: f64,
        ec: *mut i32,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn lsl_pull_chunk_str(
        in_: lsl_inlet,
        data_buffer: *mut *mut ::std::os::raw::c_char,
        timestamp_buffer: *mut f64,
        data_buffer_elements: ::std::os::raw::c_ulong,
        timestamp_buffer_elements: ::std::os::raw::c_ulong,
        timeout: f64,
        ec: *mut i32,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Pull a chunk of data from the inlet and read it into an array of binary strings."]
    #[doc = ""]
    #[doc = " These strings may contains 0's, therefore the lengths are read into the lengths_buffer array."]
    #[doc = " Handles type checking & conversion."]
    #[doc = " IMPORTANT: Note that the provided data buffer size is measured in channel values (e.g., floats)"]
    #[doc = " rather than in samples."]
    #[doc = " @param in The lsl_inlet object to act on."]
    #[doc = " @param[out] data_buffer A pointer to a buffer of data values where the results shall be stored."]
    #[doc = " @param[out] lengths_buffer A pointer to an array that holds the resulting lengths for each"]
    #[doc = " returned binary string."]
    #[doc = " @param timestamp_buffer A pointer to a buffer of timestamp values where time stamps shall be"]
    #[doc = " stored. If this is NULL, no time stamps will be returned."]
    #[doc = " @param data_buffer_elements The size of the data buffer, in channel data elements (of type T)."]
    #[doc = " Must be a multiple of the stream's channel count."]
    #[doc = " @param timestamp_buffer_elements The size of the timestamp buffer. If a timestamp buffer is"]
    #[doc = " provided then this must correspond to the same number of samples as data_buffer_elements."]
    #[doc = " @param timeout The timeout for this operation, if any."]
    #[doc = ""]
    #[doc = " When the timeout expires, the function may return before the entire buffer is filled."]
    #[doc = ""]
    #[doc = " The default value of 0.0 will retrieve only data available for immediate pickup."]
    #[doc = " @param[out] ec Error code: can be either no error or #lsl_lost_error (if the stream source has"]
    #[doc = " been lost)."]
    #[doc = " @note If the timeout expires before a new sample was received the function returns 0.0; ec is"]
    #[doc = " *not* set to #lsl_timeout_error (because this case is not considered an error condition)."]
    #[doc = " @return data_elements_written Number of channel data elements written to the data buffer."]
    pub fn lsl_pull_chunk_buf(
        in_: lsl_inlet,
        data_buffer: *mut *mut ::std::os::raw::c_char,
        lengths_buffer: *mut u32,
        timestamp_buffer: *mut f64,
        data_buffer_elements: ::std::os::raw::c_ulong,
        timestamp_buffer_elements: ::std::os::raw::c_ulong,
        timeout: f64,
        ec: *mut i32,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " Query whether samples are currently available for immediate pickup."]
    #[doc = ""]
    #[doc = " Note that it is not a good idea to use samples_available() to determine whether"]
    #[doc = " a pull_*() call would block: to be sure, set the pull timeout to 0.0 or an acceptably"]
    #[doc = " low value. If the underlying implementation supports it, the value will be the number of"]
    #[doc = " samples available (otherwise it will be 1 or 0)."]
    pub fn lsl_samples_available(in_: lsl_inlet) -> u32;
}
extern "C" {
    #[doc = " Drop all queued not-yet pulled samples, return the nr of dropped samples"]
    pub fn lsl_inlet_flush(in_: lsl_inlet) -> u32;
}
extern "C" {
    #[doc = " Query whether the clock was potentially reset since the last call to lsl_was_clock_reset()."]
    #[doc = ""]
    #[doc = " This is rarely-used function is only needed for applications that combine multiple time_correction"]
    #[doc = " values to estimate precise clock drift if they should tolerate cases where the source machine was"]
    #[doc = " hot-swapped or restarted."]
    pub fn lsl_was_clock_reset(in_: lsl_inlet) -> u32;
}
extern "C" {
    #[doc = " Override the half-time (forget factor) of the time-stamp smoothing."]
    #[doc = ""]
    #[doc = " The default is 90 seconds unless a different value is set in the config file."]
    #[doc = ""]
    #[doc = " Using a longer window will yield lower jitter in the time stamps, but longer windows will have"]
    #[doc = " trouble tracking changes in the clock rate (usually due to  temperature changes); the default is"]
    #[doc = " able to track changes up to 10  degrees C per minute sufficiently well."]
    #[doc = " @param in The lsl_inlet object to act on."]
    #[doc = " @param value The new value, in seconds. This is the time after which a past sample"]
    #[doc = "\t\t\t   will be weighted by 1/2 in the exponential smoothing window."]
    #[doc = " @return The error code: if nonzero, can be #lsl_argument_error if an unknown flag was passed in."]
    pub fn lsl_smoothing_halftime(in_: lsl_inlet, value: f32) -> i32;
}
extern "C" {
    #[doc = " Establish a new stream outlet. This makes the stream discoverable."]
    #[doc = " @param info The stream information to use for creating this stream."]
    #[doc = " Stays constant over the lifetime of the outlet."]
    #[doc = " @note the outlet makes a copy of the streaminfo object upon construction (so the old info should"]
    #[doc = " still be destroyed.)"]
    #[doc = " @param chunk_size Optionally the desired chunk granularity (in samples) for transmission."]
    #[doc = " If specified as 0, each push operation yields one chunk."]
    #[doc = " Stream recipients can have this setting bypassed."]
    #[doc = " @param max_buffered Optionally the maximum amount of data to buffer (in seconds if there is a"]
    #[doc = " nominal  sampling rate, otherwise x100 in samples). A good default is 360, which corresponds to 6"]
    #[doc = " minutes of data. Note that, for high-bandwidth data you will almost certainly want to use a lower"]
    #[doc = " value here to avoid  running out of RAM."]
    #[doc = " @return A newly created lsl_outlet handle or NULL in the event that an error occurred."]
    pub fn lsl_create_outlet(
        info: lsl_streaminfo,
        chunk_size: i32,
        max_buffered: i32,
    ) -> lsl_outlet;
}
extern "C" {
    #[doc = " @copydoc lsl_create_outlet()"]
    #[doc = " @param flags An integer that is the result of bitwise OR'ing one or more options from"]
    #[doc = " #lsl_transport_options_t together (e.g., #transp_bufsize_samples|#transp_bufsize_thousandths)"]
    pub fn lsl_create_outlet_ex(
        info: lsl_streaminfo,
        chunk_size: i32,
        max_buffered: i32,
        flags: lsl_transport_options_t,
    ) -> lsl_outlet;
}
extern "C" {
    #[doc = " Destroy an outlet."]
    #[doc = " The outlet will no longer be discoverable after destruction and all connected inlets will stop"]
    #[doc = " delivering data."]
    pub fn lsl_destroy_outlet(out: lsl_outlet);
}
extern "C" {
    #[doc = " Push a pointer to some values as a sample into the outlet."]
    #[doc = " Handles type checking & conversion."]
    #[doc = " @param out The lsl_outlet object through which to push the data."]
    #[doc = " @param data A pointer to values to push. The number of values pointed to must be no less than the"]
    #[doc = " number of channels in the sample."]
    #[doc = " #lsl_local_clock(); if omitted, the current time is used."]
    #[doc = " @return Error code of the operation or lsl_no_error if successful (usually attributed to the"]
    #[doc = " wrong data type)."]
    #[doc = " @{"]
    pub fn lsl_push_sample_f(out: lsl_outlet, data: *const f32) -> i32;
}
extern "C" {
    pub fn lsl_push_sample_d(out: lsl_outlet, data: *const f64) -> i32;
}
extern "C" {
    pub fn lsl_push_sample_l(out: lsl_outlet, data: *const i64) -> i32;
}
extern "C" {
    pub fn lsl_push_sample_i(out: lsl_outlet, data: *const i32) -> i32;
}
extern "C" {
    pub fn lsl_push_sample_s(out: lsl_outlet, data: *const i16) -> i32;
}
extern "C" {
    pub fn lsl_push_sample_c(out: lsl_outlet, data: *const ::std::os::raw::c_char) -> i32;
}
extern "C" {
    pub fn lsl_push_sample_str(out: lsl_outlet, data: *mut *const ::std::os::raw::c_char) -> i32;
}
extern "C" {
    pub fn lsl_push_sample_v(out: lsl_outlet, data: *const ::std::os::raw::c_void) -> i32;
}
extern "C" {
    #[doc = " @}"]
    #[doc = "** @copydoc lsl_push_sample_f"]
    #[doc = "* @param timestamp Optionally the capture time of the sample, in agreement with"]
    #[doc = "* @{"]
    #[doc = "*/"]
    pub fn lsl_push_sample_ft(out: lsl_outlet, data: *const f32, timestamp: f64) -> i32;
}
extern "C" {
    pub fn lsl_push_sample_dt(out: lsl_outlet, data: *const f64, timestamp: f64) -> i32;
}
extern "C" {
    pub fn lsl_push_sample_lt(out: lsl_outlet, data: *const i64, timestamp: f64) -> i32;
}
extern "C" {
    pub fn lsl_push_sample_it(out: lsl_outlet, data: *const i32, timestamp: f64) -> i32;
}
extern "C" {
    pub fn lsl_push_sample_st(out: lsl_outlet, data: *const i16, timestamp: f64) -> i32;
}
extern "C" {
    pub fn lsl_push_sample_ct(
        out: lsl_outlet,
        data: *const ::std::os::raw::c_char,
        timestamp: f64,
    ) -> i32;
}
extern "C" {
    pub fn lsl_push_sample_strt(
        out: lsl_outlet,
        data: *mut *const ::std::os::raw::c_char,
        timestamp: f64,
    ) -> i32;
}
extern "C" {
    pub fn lsl_push_sample_vt(
        out: lsl_outlet,
        data: *const ::std::os::raw::c_void,
        timestamp: f64,
    ) -> i32;
}
extern "C" {
    #[doc = " @}"]
    #[doc = "** @copydoc lsl_push_sample_ft"]
    #[doc = "* @param pushthrough Whether to push the sample through to the receivers instead of buffering it"]
    #[doc = "* with subsequent samples. Note that the chunk_size, if specified at outlet construction, takes"]
    #[doc = "* precedence over the pushthrough flag."]
    #[doc = "* @{"]
    #[doc = "*/"]
    pub fn lsl_push_sample_ftp(
        out: lsl_outlet,
        data: *const f32,
        timestamp: f64,
        pushthrough: i32,
    ) -> i32;
}
extern "C" {
    pub fn lsl_push_sample_dtp(
        out: lsl_outlet,
        data: *const f64,
        timestamp: f64,
        pushthrough: i32,
    ) -> i32;
}
extern "C" {
    pub fn lsl_push_sample_ltp(
        out: lsl_outlet,
        data: *const i64,
        timestamp: f64,
        pushthrough: i32,
    ) -> i32;
}
extern "C" {
    pub fn lsl_push_sample_itp(
        out: lsl_outlet,
        data: *const i32,
        timestamp: f64,
        pushthrough: i32,
    ) -> i32;
}
extern "C" {
    pub fn lsl_push_sample_stp(
        out: lsl_outlet,
        data: *const i16,
        timestamp: f64,
        pushthrough: i32,
    ) -> i32;
}
extern "C" {
    pub fn lsl_push_sample_ctp(
        out: lsl_outlet,
        data: *const ::std::os::raw::c_char,
        timestamp: f64,
        pushthrough: i32,
    ) -> i32;
}
extern "C" {
    pub fn lsl_push_sample_strtp(
        out: lsl_outlet,
        data: *mut *const ::std::os::raw::c_char,
        timestamp: f64,
        pushthrough: i32,
    ) -> i32;
}
extern "C" {
    pub fn lsl_push_sample_vtp(
        out: lsl_outlet,
        data: *const ::std::os::raw::c_void,
        timestamp: f64,
        pushthrough: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @copybrief lsl_push_sample_ftp"]
    #[doc = " @see lsl_push_sample_ftp"]
    #[doc = " @param out The lsl_outlet object through which to push the data."]
    #[doc = " @param data A pointer to values to push. The number of values pointed to must be no less than the"]
    #[doc = " number of channels in the sample."]
    #[doc = " @param lengths A pointer the number of elements to push for each channel (string lengths)."]
    pub fn lsl_push_sample_buf(
        out: lsl_outlet,
        data: *mut *const ::std::os::raw::c_char,
        lengths: *const u32,
    ) -> i32;
}
extern "C" {
    #[doc = " @copydoc lsl_push_sample_buf"]
    #[doc = " @param timestamp @see lsl_push_sample_ftp"]
    pub fn lsl_push_sample_buft(
        out: lsl_outlet,
        data: *mut *const ::std::os::raw::c_char,
        lengths: *const u32,
        timestamp: f64,
    ) -> i32;
}
extern "C" {
    #[doc = " @copydoc lsl_push_sample_buft"]
    #[doc = " @param pushthrough @see lsl_push_sample_ftp"]
    pub fn lsl_push_sample_buftp(
        out: lsl_outlet,
        data: *mut *const ::std::os::raw::c_char,
        lengths: *const u32,
        timestamp: f64,
        pushthrough: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Push a chunk of multiplexed samples into the outlet. One timestamp per sample is provided."]
    #[doc = ""]
    #[doc = " @attention Note that the provided buffer size is measured in channel values (e.g. floats) rather"]
    #[doc = " than in samples."]
    #[doc = ""]
    #[doc = " Handles type checking & conversion."]
    #[doc = " @param out The lsl_outlet object through which to push the data."]
    #[doc = " @param data A buffer of channel values holding the data for zero or more successive samples to"]
    #[doc = " send."]
    #[doc = " @param data_elements The number of data values (of type T) in the data buffer. Must be a multiple"]
    #[doc = " of the channel count."]
    #[doc = " @return Error code of the operation (usually attributed to the wrong data type)."]
    #[doc = " @{"]
    pub fn lsl_push_chunk_f(
        out: lsl_outlet,
        data: *const f32,
        data_elements: ::std::os::raw::c_ulong,
    ) -> i32;
}
extern "C" {
    pub fn lsl_push_chunk_d(
        out: lsl_outlet,
        data: *const f64,
        data_elements: ::std::os::raw::c_ulong,
    ) -> i32;
}
extern "C" {
    pub fn lsl_push_chunk_l(
        out: lsl_outlet,
        data: *const i64,
        data_elements: ::std::os::raw::c_ulong,
    ) -> i32;
}
extern "C" {
    pub fn lsl_push_chunk_i(
        out: lsl_outlet,
        data: *const i32,
        data_elements: ::std::os::raw::c_ulong,
    ) -> i32;
}
extern "C" {
    pub fn lsl_push_chunk_s(
        out: lsl_outlet,
        data: *const i16,
        data_elements: ::std::os::raw::c_ulong,
    ) -> i32;
}
extern "C" {
    pub fn lsl_push_chunk_c(
        out: lsl_outlet,
        data: *const ::std::os::raw::c_char,
        data_elements: ::std::os::raw::c_ulong,
    ) -> i32;
}
extern "C" {
    pub fn lsl_push_chunk_str(
        out: lsl_outlet,
        data: *mut *const ::std::os::raw::c_char,
        data_elements: ::std::os::raw::c_ulong,
    ) -> i32;
}
extern "C" {
    #[doc = " @copydoc lsl_push_chunk_f"]
    #[doc = " @param timestamp Optionally the capture time of the most recent sample, in agreement with"]
    #[doc = " lsl_local_clock(); if omitted, the current time is used."]
    #[doc = " The time stamps of other samples are automatically derived based on the sampling rate of the"]
    #[doc = " stream."]
    #[doc = " @{"]
    pub fn lsl_push_chunk_ft(
        out: lsl_outlet,
        data: *const f32,
        data_elements: ::std::os::raw::c_ulong,
        timestamp: f64,
    ) -> i32;
}
extern "C" {
    pub fn lsl_push_chunk_dt(
        out: lsl_outlet,
        data: *const f64,
        data_elements: ::std::os::raw::c_ulong,
        timestamp: f64,
    ) -> i32;
}
extern "C" {
    pub fn lsl_push_chunk_lt(
        out: lsl_outlet,
        data: *const i64,
        data_elements: ::std::os::raw::c_ulong,
        timestamp: f64,
    ) -> i32;
}
extern "C" {
    pub fn lsl_push_chunk_it(
        out: lsl_outlet,
        data: *const i32,
        data_elements: ::std::os::raw::c_ulong,
        timestamp: f64,
    ) -> i32;
}
extern "C" {
    pub fn lsl_push_chunk_st(
        out: lsl_outlet,
        data: *const i16,
        data_elements: ::std::os::raw::c_ulong,
        timestamp: f64,
    ) -> i32;
}
extern "C" {
    pub fn lsl_push_chunk_ct(
        out: lsl_outlet,
        data: *const ::std::os::raw::c_char,
        data_elements: ::std::os::raw::c_ulong,
        timestamp: f64,
    ) -> i32;
}
extern "C" {
    pub fn lsl_push_chunk_strt(
        out: lsl_outlet,
        data: *mut *const ::std::os::raw::c_char,
        data_elements: ::std::os::raw::c_ulong,
        timestamp: f64,
    ) -> i32;
}
extern "C" {
    #[doc = " @copydoc lsl_push_chunk_ft"]
    #[doc = " @param pushthrough Whether to push the chunk through to the receivers instead of buffering it"]
    #[doc = " with subsequent samples. Note that the chunk_size, if specified at outlet construction, takes"]
    #[doc = " precedence over the pushthrough flag."]
    #[doc = " @{"]
    pub fn lsl_push_chunk_ftp(
        out: lsl_outlet,
        data: *const f32,
        data_elements: ::std::os::raw::c_ulong,
        timestamp: f64,
        pushthrough: i32,
    ) -> i32;
}
extern "C" {
    pub fn lsl_push_chunk_dtp(
        out: lsl_outlet,
        data: *const f64,
        data_elements: ::std::os::raw::c_ulong,
        timestamp: f64,
        pushthrough: i32,
    ) -> i32;
}
extern "C" {
    pub fn lsl_push_chunk_ltp(
        out: lsl_outlet,
        data: *const i64,
        data_elements: ::std::os::raw::c_ulong,
        timestamp: f64,
        pushthrough: i32,
    ) -> i32;
}
extern "C" {
    pub fn lsl_push_chunk_itp(
        out: lsl_outlet,
        data: *const i32,
        data_elements: ::std::os::raw::c_ulong,
        timestamp: f64,
        pushthrough: i32,
    ) -> i32;
}
extern "C" {
    pub fn lsl_push_chunk_stp(
        out: lsl_outlet,
        data: *const i16,
        data_elements: ::std::os::raw::c_ulong,
        timestamp: f64,
        pushthrough: i32,
    ) -> i32;
}
extern "C" {
    pub fn lsl_push_chunk_ctp(
        out: lsl_outlet,
        data: *const ::std::os::raw::c_char,
        data_elements: ::std::os::raw::c_ulong,
        timestamp: f64,
        pushthrough: i32,
    ) -> i32;
}
extern "C" {
    pub fn lsl_push_chunk_strtp(
        out: lsl_outlet,
        data: *mut *const ::std::os::raw::c_char,
        data_elements: ::std::os::raw::c_ulong,
        timestamp: f64,
        pushthrough: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @}"]
    #[doc = "** @copydoc lsl_push_chunk_f"]
    #[doc = "* @param timestamps Buffer holding one time stamp for each sample in the data buffer."]
    #[doc = "* @{"]
    #[doc = "*/"]
    pub fn lsl_push_chunk_ftn(
        out: lsl_outlet,
        data: *const f32,
        data_elements: ::std::os::raw::c_ulong,
        timestamps: *const f64,
    ) -> i32;
}
extern "C" {
    pub fn lsl_push_chunk_dtn(
        out: lsl_outlet,
        data: *const f64,
        data_elements: ::std::os::raw::c_ulong,
        timestamps: *const f64,
    ) -> i32;
}
extern "C" {
    pub fn lsl_push_chunk_ltn(
        out: lsl_outlet,
        data: *const i64,
        data_elements: ::std::os::raw::c_ulong,
        timestamps: *const f64,
    ) -> i32;
}
extern "C" {
    pub fn lsl_push_chunk_itn(
        out: lsl_outlet,
        data: *const i32,
        data_elements: ::std::os::raw::c_ulong,
        timestamps: *const f64,
    ) -> i32;
}
extern "C" {
    pub fn lsl_push_chunk_stn(
        out: lsl_outlet,
        data: *const i16,
        data_elements: ::std::os::raw::c_ulong,
        timestamps: *const f64,
    ) -> i32;
}
extern "C" {
    pub fn lsl_push_chunk_ctn(
        out: lsl_outlet,
        data: *const ::std::os::raw::c_char,
        data_elements: ::std::os::raw::c_ulong,
        timestamps: *const f64,
    ) -> i32;
}
extern "C" {
    pub fn lsl_push_chunk_strtn(
        out: lsl_outlet,
        data: *mut *const ::std::os::raw::c_char,
        data_elements: ::std::os::raw::c_ulong,
        timestamps: *const f64,
    ) -> i32;
}
extern "C" {
    #[doc = " @copydoc lsl_push_chunk_ftn"]
    #[doc = " @param pushthrough Whether to push the chunk through to the receivers instead of buffering it"]
    #[doc = " with subsequent samples. Note that the chunk_size, if specified at outlet construction, takes"]
    #[doc = " precedence over the pushthrough flag."]
    #[doc = " @{"]
    pub fn lsl_push_chunk_ftnp(
        out: lsl_outlet,
        data: *const f32,
        data_elements: ::std::os::raw::c_ulong,
        timestamps: *const f64,
        pushthrough: i32,
    ) -> i32;
}
extern "C" {
    pub fn lsl_push_chunk_dtnp(
        out: lsl_outlet,
        data: *const f64,
        data_elements: ::std::os::raw::c_ulong,
        timestamps: *const f64,
        pushthrough: i32,
    ) -> i32;
}
extern "C" {
    pub fn lsl_push_chunk_ltnp(
        out: lsl_outlet,
        data: *const i64,
        data_elements: ::std::os::raw::c_ulong,
        timestamps: *const f64,
        pushthrough: i32,
    ) -> i32;
}
extern "C" {
    pub fn lsl_push_chunk_itnp(
        out: lsl_outlet,
        data: *const i32,
        data_elements: ::std::os::raw::c_ulong,
        timestamps: *const f64,
        pushthrough: i32,
    ) -> i32;
}
extern "C" {
    pub fn lsl_push_chunk_stnp(
        out: lsl_outlet,
        data: *const i16,
        data_elements: ::std::os::raw::c_ulong,
        timestamps: *const f64,
        pushthrough: i32,
    ) -> i32;
}
extern "C" {
    pub fn lsl_push_chunk_ctnp(
        out: lsl_outlet,
        data: *const ::std::os::raw::c_char,
        data_elements: ::std::os::raw::c_ulong,
        timestamps: *const f64,
        pushthrough: i32,
    ) -> i32;
}
extern "C" {
    pub fn lsl_push_chunk_strtnp(
        out: lsl_outlet,
        data: *mut *const ::std::os::raw::c_char,
        data_elements: ::std::os::raw::c_ulong,
        timestamps: *const f64,
        pushthrough: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @copybrief lsl_push_chunk_ftp"]
    #[doc = " @sa lsl_push_chunk_ftp"]
    #[doc = " @param out The lsl_outlet object through which to push the data."]
    #[doc = " @param data An array of channel values holding the data to push."]
    #[doc = " @param lengths Pointer the number of elements to push for each value (string lengths) so that"]
    #[doc = " `size(data[i])==lengths[i]`."]
    #[doc = " @param data_elements The number of data values in the data buffer."]
    #[doc = " Must be a multiple of the channel count."]
    pub fn lsl_push_chunk_buf(
        out: lsl_outlet,
        data: *mut *const ::std::os::raw::c_char,
        lengths: *const u32,
        data_elements: ::std::os::raw::c_ulong,
    ) -> i32;
}
extern "C" {
    #[doc = " @copydoc lsl_push_chunk_buf @sa lsl_push_chunk_ftp @sa lsl_push_chunk_buf"]
    #[doc = " @param timestamp Optionally the capture time of the most recent sample, in agreement with"]
    #[doc = " lsl_local_clock(); if omitted, the current time is used."]
    #[doc = " The time stamps of other samples are automatically derived based on the sampling rate of the"]
    #[doc = " stream."]
    pub fn lsl_push_chunk_buft(
        out: lsl_outlet,
        data: *mut *const ::std::os::raw::c_char,
        lengths: *const u32,
        data_elements: ::std::os::raw::c_ulong,
        timestamp: f64,
    ) -> i32;
}
extern "C" {
    #[doc = " @copydoc lsl_push_chunk_buft @sa lsl_push_chunk_ftp @sa lsl_push_chunk_buf"]
    #[doc = " @param pushthrough Whether to push the chunk through to the receivers instead of buffering it"]
    #[doc = " with subsequent samples. Note that the chunk_size, if specified at outlet construction, takes"]
    #[doc = " precedence over the pushthrough flag."]
    pub fn lsl_push_chunk_buftp(
        out: lsl_outlet,
        data: *mut *const ::std::os::raw::c_char,
        lengths: *const u32,
        data_elements: ::std::os::raw::c_ulong,
        timestamp: f64,
        pushthrough: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " @copydoc lsl_push_chunk_buf @sa lsl_push_chunk_ftp @sa lsl_push_chunk_buf"]
    #[doc = " @param timestamps Buffer holding one time stamp for each sample in the data buffer."]
    pub fn lsl_push_chunk_buftn(
        out: lsl_outlet,
        data: *mut *const ::std::os::raw::c_char,
        lengths: *const u32,
        data_elements: ::std::os::raw::c_ulong,
        timestamps: *const f64,
    ) -> i32;
}
extern "C" {
    #[doc = " @copydoc lsl_push_chunk_buftn @sa lsl_push_chunk_ftp @sa lsl_push_chunk_buf"]
    #[doc = " @param pushthrough Whether to push the chunk through to the receivers instead of buffering it"]
    #[doc = " with subsequent samples. Note that the chunk_size, if specified at outlet construction, takes"]
    #[doc = " precedence over the pushthrough flag."]
    pub fn lsl_push_chunk_buftnp(
        out: lsl_outlet,
        data: *mut *const ::std::os::raw::c_char,
        lengths: *const u32,
        data_elements: ::std::os::raw::c_ulong,
        timestamps: *const f64,
        pushthrough: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Check whether consumers are currently registered."]
    #[doc = " While it does not hurt, there is technically no reason to push samples if there is no consumer."]
    pub fn lsl_have_consumers(out: lsl_outlet) -> i32;
}
extern "C" {
    #[doc = " Wait until some consumer shows up (without wasting resources)."]
    #[doc = " @return True if the wait was successful, false if the timeout expired."]
    pub fn lsl_wait_for_consumers(out: lsl_outlet, timeout: f64) -> i32;
}
extern "C" {
    #[doc = " Retrieve a handle to the stream info provided by this outlet."]
    #[doc = " This is what was used to create the stream (and also has the Additional Network Information"]
    #[doc = " fields assigned)."]
    #[doc = " @return A copy of the streaminfo of the outlet or NULL in the event that an error occurred."]
    #[doc = " @note It is the user's responsibility to destroy it when it is no longer needed."]
    #[doc = " @sa lsl_destroy_string()"]
    pub fn lsl_get_info(out: lsl_outlet) -> lsl_streaminfo;
}
extern "C" {
    #[doc = " Construct a new #lsl_continuous_resolver that resolves all streams on the network."]
    #[doc = ""]
    #[doc = " This is analogous to the functionality offered by the free function lsl_resolve_streams()."]
    #[doc = " @param forget_after When a stream is no longer visible on the network (e.g. because it was shut"]
    #[doc = " down), this is the time in seconds after which it is no longer reported by the resolver."]
    #[doc = ""]
    #[doc = " The recommended default value is 5.0."]
    pub fn lsl_create_continuous_resolver(forget_after: f64) -> lsl_continuous_resolver;
}
extern "C" {
    #[doc = " Construct a new lsl_continuous_resolver that resolves all streams with a specific value for a given"]
    #[doc = " property."]
    #[doc = ""]
    #[doc = " This is analogous to the functionality provided by the free function lsl_resolve_byprop()"]
    #[doc = " @param prop The #lsl_streaminfo property that should have a specific value (e.g., \"name\", \"type\","]
    #[doc = " \"source_id\", or \"desc/manufaturer\")."]
    #[doc = " @param value The string value that the property should have (e.g., \"EEG\" as the type property)."]
    #[doc = " @param forget_after When a stream is no longer visible on the network (e.g., because it was shut"]
    #[doc = " down), this is the time in seconds after which it is no longer reported by the resolver."]
    #[doc = " The recommended default value is 5.0."]
    pub fn lsl_create_continuous_resolver_byprop(
        prop: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
        forget_after: f64,
    ) -> lsl_continuous_resolver;
}
extern "C" {
    #[doc = " Construct a new lsl_continuous_resolver that resolves all streams that match a given XPath 1.0"]
    #[doc = " predicate."]
    #[doc = ""]
    #[doc = " This is analogous to the functionality provided by the free function lsl_resolve_bypred()"]
    #[doc = " @param pred The predicate string, e.g."]
    #[doc = " `\"name='BioSemi'\" or \"type='EEG' and starts-with(name,'BioSemi') and count(info/desc/channel)=32\"`"]
    #[doc = " @param forget_after When a stream is no longer visible on the network (e.g., because it was shut"]
    #[doc = " down), this is the time in seconds after which it is no longer reported by the resolver."]
    #[doc = " The recommended default value is 5.0."]
    pub fn lsl_create_continuous_resolver_bypred(
        pred: *const ::std::os::raw::c_char,
        forget_after: f64,
    ) -> lsl_continuous_resolver;
}
extern "C" {
    #[doc = " Obtain the set of currently present streams on the network (i.e. resolve result)."]
    #[doc = ""]
    #[doc = " @param res A continuous resolver (previously created with one of the"]
    #[doc = " lsl_create_continuous_resolver() functions)."]
    #[doc = " @param buffer A user-allocated buffer to hold the current resolve results.<br>"]
    #[doc = " @attention It is the user's responsibility to either destroy the resulting streaminfo objects or"]
    #[doc = " to pass them back to the LSL during during creation of an inlet."]
    #[doc = " @attention The stream_infos returned by the resolver are only short versions that do not include"]
    #[doc = " the lsl_get_desc() field (which can be arbitrarily big)."]
    #[doc = ""]
    #[doc = " To obtain the full stream information you need to call lsl_get_info() on the inlet after you have"]
    #[doc = " created one."]
    #[doc = " @param buffer_elements The user-provided buffer length."]
    #[doc = " @return The number of results written into the buffer (never more than the provided # of slots)"]
    #[doc = " or a negative number if an error has occurred (values corresponding to #lsl_error_code_t)."]
    pub fn lsl_resolver_results(
        res: lsl_continuous_resolver,
        buffer: *mut lsl_streaminfo,
        buffer_elements: u32,
    ) -> i32;
}
extern "C" {
    #[doc = " Destructor for the continuous resolver."]
    pub fn lsl_destroy_continuous_resolver(res: lsl_continuous_resolver);
}
extern "C" {
    #[doc = " Resolve all streams on the network."]
    #[doc = ""]
    #[doc = " This function returns all currently available streams from any outlet on the network."]
    #[doc = " The network is usually the subnet specified at the local router, but may also include a multicast"]
    #[doc = " group of machines (given that the network supports it), or a list of hostnames.<br>"]
    #[doc = " These details may optionally be customized by the experimenter in a configuration file"]
    #[doc = " (see page Network Connectivity in the LSL wiki)."]
    #[doc = " This is the default mechanism used by the browsing programs and the recording program."]
    #[doc = " @param[out] buffer A user-allocated buffer to hold the resolve results."]
    #[doc = " @attention It is the user's responsibility to either destroy the resulting streaminfo objects or"]
    #[doc = " to pass them back to the LSL during during creation of an inlet."]
    #[doc = ""]
    #[doc = " @attention The stream_info's returned by the resolver are only short versions that do not include"]
    #[doc = " the lsl_get_desc() field (which can be arbitrarily big)."]
    #[doc = " To obtain the full stream information you need to call lsl_get_info() on the inlet after you have"]
    #[doc = " created one."]
    #[doc = " @param buffer_elements The user-provided buffer length."]
    #[doc = " @param wait_time The waiting time for the operation, in seconds, to search for streams."]
    #[doc = " The recommended wait time is 1 second (or 2 for a busy and large recording operation)."]
    #[doc = " @warning If this is too short (<0.5s) only a subset (or none) of the outlets that are present on"]
    #[doc = " the network may be returned."]
    #[doc = " @return The number of results written into the buffer (never more than the provided # of slots)"]
    #[doc = "         or a negative number if an error has occurred (values corresponding to lsl_error_code_t)."]
    pub fn lsl_resolve_all(
        buffer: *mut lsl_streaminfo,
        buffer_elements: u32,
        wait_time: f64,
    ) -> i32;
}
extern "C" {
    #[doc = " Resolve all streams with a given value for a property."]
    #[doc = ""]
    #[doc = " If the goal is to resolve a specific stream, this method is preferred over resolving all streams"]
    #[doc = " and then selecting the desired one."]
    #[doc = " @param[out] buffer A user-allocated buffer to hold the resolve results."]
    #[doc = " @attention It is the user's responsibility to either destroy the resulting streaminfo objects or"]
    #[doc = " to pass them back to the LSL during during creation of an inlet."]
    #[doc = ""]
    #[doc = " @attention The stream_info's returned by the resolver are only short versions that do not include"]
    #[doc = " the lsl_get_desc() field (which can be arbitrarily big). To obtain the full stream information"]
    #[doc = " you need to call lsl_get_info() on the inlet after you have created one."]
    #[doc = " @param buffer_elements The user-provided buffer length."]
    #[doc = " @param prop The streaminfo property that should have a specific value (`\"name\"`, `\"type\"`,"]
    #[doc = " `\"source_id\"`, or, e.g., `\"desc/manufaturer\"` if present)."]
    #[doc = " @param value The string value that the property should have (e.g., \"EEG\" as the type)."]
    #[doc = " @param minimum Return at least this number of streams."]
    #[doc = " @param timeout Optionally a timeout of the operation, in seconds (default: no timeout)."]
    #[doc = " If the timeout expires, less than the desired number of streams (possibly none) will be returned."]
    #[doc = " @return The number of results written into the buffer (never more than the provided # of slots)"]
    #[doc = " or a negative number if an error has occurred (values corresponding to #lsl_error_code_t)."]
    pub fn lsl_resolve_byprop(
        buffer: *mut lsl_streaminfo,
        buffer_elements: u32,
        prop: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
        minimum: i32,
        timeout: f64,
    ) -> i32;
}
extern "C" {
    #[doc = " Resolve all streams that match a given predicate."]
    #[doc = ""]
    #[doc = " Advanced query that allows to impose more conditions on the retrieved streams;"]
    #[doc = " the given string is an [XPath 1.0 predicate](http://en.wikipedia.org/w/index.php?title=XPath_1.0)"]
    #[doc = " for the `<info>` node (omitting the surrounding []'s)"]
    #[doc = " @param[out] buffer A user-allocated buffer to hold the resolve results."]
    #[doc = " @attention It is the user's responsibility to either destroy the resulting streaminfo objects or"]
    #[doc = " to pass them back to the LSL during during creation of an inlet."]
    #[doc = ""]
    #[doc = " @attention The stream_info's returned by the resolver are only short versions that do not include"]
    #[doc = " the lsl_get_desc() field (which can be arbitrarily big). To obtain the full stream information"]
    #[doc = " you need to call lsl_get_info() on the inlet after you have created one."]
    #[doc = " @param buffer_elements The user-provided buffer length."]
    #[doc = " @param pred The predicate string, e.g."]
    #[doc = " `name='BioSemi'` or `type='EEG' and starts-with(name,'BioSemi') and count(info/desc/channel)=32`"]
    #[doc = " @param minimum Return at least this number of streams."]
    #[doc = " @param timeout Optionally a timeout of the operation, in seconds (default: no timeout)."]
    #[doc = "                If the timeout expires, less than the desired number of streams (possibly none)"]
    #[doc = " will be returned."]
    #[doc = " @return The number of results written into the buffer (never more than the provided # of slots)"]
    #[doc = "         or a negative number if an error has occurred (values corresponding to lsl_error_code_t)."]
    pub fn lsl_resolve_bypred(
        buffer: *mut lsl_streaminfo,
        buffer_elements: u32,
        pred: *const ::std::os::raw::c_char,
        minimum: i32,
        timeout: f64,
    ) -> i32;
}
extern "C" {
    #[doc = " Construct a new streaminfo object."]
    #[doc = ""]
    #[doc = " Core stream information is specified here. Any remaining meta-data can be added later."]
    #[doc = " @param name Name of the stream.<br>"]
    #[doc = " Describes the device (or product series) that this stream makes available"]
    #[doc = "             (for use by programs, experimenters or data analysts). Cannot be empty."]
    #[doc = " @param type Content type of the stream. Please see https://github.com/sccn/xdf/wiki/Meta-Data (or"]
    #[doc = " web search for: XDF meta-data) for pre-defined content-type names, but you can also make up your"]
    #[doc = " own. The content type is the preferred way to find streams (as opposed to searching by name)."]
    #[doc = " @param channel_count Number of channels per sample."]
    #[doc = " This stays constant for the lifetime of the stream."]
    #[doc = " @param nominal_srate The sampling rate (in Hz) as advertised by the"]
    #[doc = " datasource, if regular (otherwise set to #LSL_IRREGULAR_RATE)."]
    #[doc = " @param channel_format Format/type of each channel.<br>"]
    #[doc = " If your channels have different formats, consider supplying multiple streams"]
    #[doc = " or use the largest type that can hold them all (such as #cft_double64)."]
    #[doc = ""]
    #[doc = " A good default is #cft_float32."]
    #[doc = " @param source_id Unique identifier of the source or device, if available (e.g. a serial number)."]
    #[doc = " Allows recipients to recover from failure even after the serving app or device crashes."]
    #[doc = " May in some cases also be constructed from device settings."]
    #[doc = " @return A newly created streaminfo handle or NULL in the event that an error occurred."]
    pub fn lsl_create_streaminfo(
        name: *const ::std::os::raw::c_char,
        type_: *const ::std::os::raw::c_char,
        channel_count: i32,
        nominal_srate: f64,
        channel_format: lsl_channel_format_t,
        source_id: *const ::std::os::raw::c_char,
    ) -> lsl_streaminfo;
}
extern "C" {
    #[doc = " Destroy a previously created streaminfo object."]
    pub fn lsl_destroy_streaminfo(info: lsl_streaminfo);
}
extern "C" {
    #[doc = " Copy an existing streaminfo object (rarely used)."]
    pub fn lsl_copy_streaminfo(info: lsl_streaminfo) -> lsl_streaminfo;
}
extern "C" {
    #[doc = " Name of the stream."]
    #[doc = ""]
    #[doc = " This is a human-readable name."]
    #[doc = " For streams offered by device modules, it refers to the type of device or product series  that is"]
    #[doc = " generating the data of the stream. If the source is an application, the name may be a more"]
    #[doc = " generic or specific identifier. Multiple streams with the same name can coexist, though"]
    #[doc = " potentially at the cost of ambiguity (for the recording app or experimenter)."]
    #[doc = " @return An immutable library-owned pointer to the string value. @sa lsl_destroy_string()"]
    pub fn lsl_get_name(info: lsl_streaminfo) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Content type of the stream."]
    #[doc = ""]
    #[doc = " The content type is a short string such as \"EEG\", \"Gaze\" which describes the content carried by"]
    #[doc = " the channel (if known). If a stream contains mixed content this value need not be assigned but"]
    #[doc = " may instead be stored in the description of channel types. To be useful to applications and"]
    #[doc = " automated processing systems using the recommended content types is preferred. Content types"]
    #[doc = " usually follow those pre-defined in the [wiki](https://github.com/sccn/xdf/wiki/Meta-Data) (or"]
    #[doc = " web search for: XDF meta-data)."]
    #[doc = " @return An immutable library-owned pointer to the string value. @sa lsl_destroy_string()"]
    pub fn lsl_get_type(info: lsl_streaminfo) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Number of channels of the stream."]
    #[doc = " A stream has at least one channels; the channel count stays constant for all samples."]
    pub fn lsl_get_channel_count(info: lsl_streaminfo) -> i32;
}
extern "C" {
    #[doc = " Sampling rate of the stream, according to the source (in Hz)."]
    #[doc = ""]
    #[doc = " If a stream is irregularly sampled, this should be set to #LSL_IRREGULAR_RATE."]
    #[doc = ""]
    #[doc = " Note that no data will be lost even if this sampling rate is incorrect or if a device has"]
    #[doc = " temporary hiccups, since all samples will be recorded anyway (except for those dropped by the"]
    #[doc = " device itself). However, when the recording is imported into an application, a good importer may"]
    #[doc = " correct such errors more accurately if the advertised sampling rate was close to the specs of the"]
    #[doc = " device."]
    pub fn lsl_get_nominal_srate(info: lsl_streaminfo) -> f64;
}
extern "C" {
    #[doc = " Channel format of the stream."]
    #[doc = " All channels in a stream have the same format."]
    #[doc = " However, a device might offer multiple time-synched streams  each with its own format."]
    pub fn lsl_get_channel_format(info: lsl_streaminfo) -> lsl_channel_format_t;
}
extern "C" {
    #[doc = " Unique identifier of the stream's source, if available."]
    #[doc = ""]
    #[doc = " The unique source (or device) identifier is an optional piece of information that, if available,"]
    #[doc = " allows that endpoints (such as the recording program) can re-acquire a stream automatically once"]
    #[doc = " it is back online."]
    #[doc = " @return An immutable library-owned pointer to the string value. @sa lsl_destroy_string()"]
    pub fn lsl_get_source_id(info: lsl_streaminfo) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Protocol version used to deliver the stream."]
    pub fn lsl_get_version(info: lsl_streaminfo) -> i32;
}
extern "C" {
    #[doc = " Creation time stamp of the stream."]
    #[doc = ""]
    #[doc = " This is the time stamp when the stream was first created"]
    #[doc = " (as determined via local_clock() on the providing machine)."]
    pub fn lsl_get_created_at(info: lsl_streaminfo) -> f64;
}
extern "C" {
    #[doc = " Unique ID of the stream outlet (once assigned)."]
    #[doc = ""]
    #[doc = " This is a unique identifier of the stream outlet, and is guaranteed to be different"]
    #[doc = " across multiple instantiations of the same outlet (e.g., after a re-start)."]
    #[doc = " @return An immutable library-owned pointer to the string value. @sa lsl_destroy_string()"]
    pub fn lsl_get_uid(info: lsl_streaminfo) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Session ID for the given stream."]
    #[doc = ""]
    #[doc = " The session id is an optional human-assigned identifier of the recording session."]
    #[doc = " While it is rarely used, it can be used to prevent concurrent recording activitites"]
    #[doc = " on the same sub-network (e.g., in multiple experiment areas) from seeing each other's streams"]
    #[doc = " (assigned via a configuration file by the experimenter, see Network Connectivity on the LSL"]
    #[doc = " wiki)."]
    #[doc = " @return An immutable library-owned pointer to the string value. @sa lsl_destroy_string()"]
    pub fn lsl_get_session_id(info: lsl_streaminfo) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Hostname of the providing machine (once bound to an outlet). Modification is not permitted."]
    pub fn lsl_get_hostname(info: lsl_streaminfo) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Extended description of the stream."]
    #[doc = ""]
    #[doc = " It is highly recommended that at least the channel labels are described here."]
    #[doc = " See code examples on the LSL wiki. Other information, such as amplifier settings,"]
    #[doc = " measurement units if deviating from defaults, setup information, subject information, etc.,"]
    #[doc = " can be specified here, as well. Meta-data recommendations follow the XDF file format project"]
    #[doc = " (github.com/sccn/xdf/wiki/Meta-Data or web search for: XDF meta-data)."]
    #[doc = ""]
    #[doc = " @attention if you use a stream content type for which meta-data recommendations exist, please"]
    #[doc = " try to lay out your meta-data in agreement with these recommendations for compatibility with other applications."]
    pub fn lsl_get_desc(info: lsl_streaminfo) -> lsl_xml_ptr;
}
extern "C" {
    #[doc = " Retrieve the entire streaminfo in XML format."]
    #[doc = ""]
    #[doc = " This yields an XML document (in string form) whose top-level element is `<info>`. The info"]
    #[doc = " element contains one element for each field of the streaminfo class, including:"]
    #[doc = ""]
    #[doc = "   - the core elements `<name>`, `<type>`, `<channel_count`, `<nominal_srate>`,"]
    #[doc = "   `<channel_format>`, `<source_id>`"]
    #[doc = "   - the misc elements `<version>`, `<created_at>`, `<uid>`, `<session_id>`,"]
    #[doc = "   `<v4address>`, `<v4data_port>`, `<v4service_port>`, `<v6address>`, `<v6data_port>`,"]
    #[doc = "   `<v6service_port>`"]
    #[doc = "   - the extended description element `<desc>` with user-defined sub-elements."]
    #[doc = " @return A pointer to a copy of the XML text or NULL in the event that an error occurred."]
    #[doc = " @note It is the user's responsibility to deallocate this string when it is no longer needed."]
    pub fn lsl_get_xml(info: lsl_streaminfo) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Number of bytes occupied by a channel (0 for string-typed channels)."]
    pub fn lsl_get_channel_bytes(info: lsl_streaminfo) -> i32;
}
extern "C" {
    #[doc = " Number of bytes occupied by a sample (0 for string-typed channels)."]
    pub fn lsl_get_sample_bytes(info: lsl_streaminfo) -> i32;
}
extern "C" {
    #[doc = " Tries to match the stream info XML element @p info against an"]
    #[doc = " <a href=\"https://en.wikipedia.org/wiki/XPath#Syntax_and_semantics_(XPath_1.0)\">XPath</a> query."]
    #[doc = ""]
    #[doc = " Example query strings:"]
    #[doc = " @code"]
    #[doc = " channel_count>5 and type='EEG'"]
    #[doc = " type='TestStream' or contains(name,'Brain')"]
    #[doc = " name='ExampleStream'"]
    #[doc = " @endcode"]
    pub fn lsl_stream_info_matches_query(
        info: lsl_streaminfo,
        query: *const ::std::os::raw::c_char,
    ) -> i32;
}
extern "C" {
    #[doc = " Create a streaminfo object from an XML representation"]
    pub fn lsl_streaminfo_from_xml(xml: *const ::std::os::raw::c_char) -> lsl_streaminfo;
}
extern "C" {
    #[doc = " Get the first child of the element."]
    pub fn lsl_first_child(e: lsl_xml_ptr) -> lsl_xml_ptr;
}
extern "C" {
    #[doc = " Get the last child of the element."]
    pub fn lsl_last_child(e: lsl_xml_ptr) -> lsl_xml_ptr;
}
extern "C" {
    #[doc = " Get the next sibling in the children list of the parent node."]
    pub fn lsl_next_sibling(e: lsl_xml_ptr) -> lsl_xml_ptr;
}
extern "C" {
    #[doc = " Get the previous sibling in the children list of the parent node."]
    pub fn lsl_previous_sibling(e: lsl_xml_ptr) -> lsl_xml_ptr;
}
extern "C" {
    #[doc = " Get the parent node."]
    pub fn lsl_parent(e: lsl_xml_ptr) -> lsl_xml_ptr;
}
extern "C" {
    #[doc = " Get a child with a specified name."]
    pub fn lsl_child(e: lsl_xml_ptr, name: *const ::std::os::raw::c_char) -> lsl_xml_ptr;
}
extern "C" {
    #[doc = " Get the next sibling with the specified name."]
    pub fn lsl_next_sibling_n(e: lsl_xml_ptr, name: *const ::std::os::raw::c_char) -> lsl_xml_ptr;
}
extern "C" {
    #[doc = " Get the previous sibling with the specified name."]
    pub fn lsl_previous_sibling_n(
        e: lsl_xml_ptr,
        name: *const ::std::os::raw::c_char,
    ) -> lsl_xml_ptr;
}
extern "C" {
    #[doc = " Whether this node is empty."]
    pub fn lsl_empty(e: lsl_xml_ptr) -> i32;
}
extern "C" {
    #[doc = " Whether this is a text body (instead of an XML element). True both for plain char data and CData."]
    pub fn lsl_is_text(e: lsl_xml_ptr) -> i32;
}
extern "C" {
    #[doc = " Name of the element."]
    pub fn lsl_name(e: lsl_xml_ptr) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Value of the element."]
    pub fn lsl_value(e: lsl_xml_ptr) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get child value (value of the first child that is text)."]
    pub fn lsl_child_value(e: lsl_xml_ptr) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get child value of a child with a specified name."]
    pub fn lsl_child_value_n(
        e: lsl_xml_ptr,
        name: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Append a child node with a given name, which has a (nameless) plain-text child with the given text value."]
    pub fn lsl_append_child_value(
        e: lsl_xml_ptr,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> lsl_xml_ptr;
}
extern "C" {
    #[doc = " Prepend a child node with a given name, which has a (nameless) plain-text child with the given text value."]
    pub fn lsl_prepend_child_value(
        e: lsl_xml_ptr,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> lsl_xml_ptr;
}
extern "C" {
    #[doc = " Set the text value of the (nameless) plain-text child of a named child node."]
    pub fn lsl_set_child_value(
        e: lsl_xml_ptr,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> i32;
}
extern "C" {
    #[doc = " Set the element's name."]
    #[doc = " @return 0 if the node is empty (or if out of memory)."]
    pub fn lsl_set_name(e: lsl_xml_ptr, rhs: *const ::std::os::raw::c_char) -> i32;
}
extern "C" {
    #[doc = " Set the element's value."]
    #[doc = " @return 0 if the node is empty (or if out of memory)."]
    pub fn lsl_set_value(e: lsl_xml_ptr, rhs: *const ::std::os::raw::c_char) -> i32;
}
extern "C" {
    #[doc = " Append a child element with the specified name."]
    pub fn lsl_append_child(e: lsl_xml_ptr, name: *const ::std::os::raw::c_char) -> lsl_xml_ptr;
}
extern "C" {
    #[doc = " Prepend a child element with the specified name."]
    pub fn lsl_prepend_child(e: lsl_xml_ptr, name: *const ::std::os::raw::c_char) -> lsl_xml_ptr;
}
extern "C" {
    #[doc = " Append a copy of the specified element as a child."]
    pub fn lsl_append_copy(e: lsl_xml_ptr, e2: lsl_xml_ptr) -> lsl_xml_ptr;
}
extern "C" {
    #[doc = " Prepend a child element with the specified name."]
    pub fn lsl_prepend_copy(e: lsl_xml_ptr, e2: lsl_xml_ptr) -> lsl_xml_ptr;
}
extern "C" {
    #[doc = " Remove a child element with the specified name."]
    pub fn lsl_remove_child_n(e: lsl_xml_ptr, name: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Remove a specified child element."]
    pub fn lsl_remove_child(e: lsl_xml_ptr, e2: lsl_xml_ptr);
}
